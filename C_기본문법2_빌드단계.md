# C

## 함수 기본

```C
#include <stdio.h>

void honk(void)
{
    printf('Honk~');
}

void reduce_gas(float consumed_gas)
{
    s_gas -= consumed_gas;
}
```
* C의 함수는 모두 전역(global)함수  
즉 C함수는 어디서든 호출할 수 있는데, 이를 제한할 수 있는 키워드가 있음  
함수 오버로딩 안되므로, 함수 명 다르게 만들어줘야 함.  
C는 코드를 위에서 아래로 훑음.  함수 정의 전에 그 함수를 호출하면 컴파일러가 해당 함수 반환형은 int라고 가정, 매개변수는 아무거나 올 수 있음.  
sol) 함수를 스크립트 위에 정의하면 되지만, 프로그래밍하기 어려워짐.  
sol2) 헤더파일에 정의  
sol2) 함수 선언 : 함수의 구현체 없이 함수원형(prototype)만 선어해주는 것  
:  함수 이름, 반환형, 매개변수들의 자료형을 명시해줌  

```C
void foo(void);  /* 함수 (전방) 선언, forward declaration */
int main(void)
{
    foo{};
    getchar();
    return 0;
}
void foo(void)  /* 함수 정의 */
{
    print('~~');
}

* 실제 어디로 가서 코드를 찾아야하는지 모르니 구멍으로 남김.
함수 정의된 메모리 주소로 jump해야 하는데, 어디로 jump할지는 아직 모르니 구멍으로. 
컴파일 다음 단계인 링크(link) 단계에서 실제 코드 위치를 찾아서 구멍 메꿔줌.

* int반환할거면 선언귀찮게 안해도 되나? NO !!!!!
C99에서는 int가정 안하므로, 컴파일 안될 수 있음. 컴파일러마다 다름.
```

## 함수 매개변수 평가 순서, 피여산자 평가 순서
```C
int main(void)
{
    int num1 = 128;
    int num2 = 256;
    
    printf("%d, %d\n", add(num1, num2), subtract(num1, num2));
    /* add, subtract두 함수 중 어떤게 먼저 호출될 지 모름!*/
    return 0;
}

* 함수 매개변수의 평가 순서는 명시되지 않음 (unspecified)
컴파일러에 따라 평가 순서가 달라질 수 있음.

if (find_next_dungeon() + spawn_monster() == 2)
{
...
}  /*여기서 두 함수가 같은 변수 size_t g_boss 를 같이 제어한다고 하면, 함수 호출 순서가 unspecified이기 때문에, 엉둥하게 작동할 수 있음*/

; 는 sequence point. 한 줄이 끝남을 명시, 다른 줄보다 먼저 실행됨을 강제함.  
for (i=0; i<10; ++i) 안의 ;도 순서를 명시해주는 역할 함

# undefinded behavior
정의되지 않았으므로, 첫번째 인자가 먼저 평가되거나, 두번째인자가 먼저 평가되거나, 동시에 평가될 수도 있는데 어떻게 작동할 지 모름. !!!
unspecified는 둘중어떤게 하나가 먼저 실행되는지는 명확한 상태.


한줄에 동일한 변수를 두번(여러번) 바꾸는 일만 피하면 됨.
함수 매개변수 평가 순서는 컴파일러마다 다를수 있음.
프로그래밍 언어마다 특정 순서 보장하는 경우도 있음.  
i = ++i + i++   /*어떤 일이 일어날지 undefined */
i = i++ + 1;    /*어떤 일이 일어날지 undefined */
array[i] = i++; /*어떤 일이 일어날지 undefined */

i = i+1는 한번만 고쳐지므로 문제 없음.

add(n1, n2) + subtract(n1, n2) * divide(n1, n2); 도
add, subtract, divide뭐가 먼저 호출될지는 모름. call 이후 연산순서는 곱셈먼저긴 하지.
```

```C
int i = 0;
int j = 0;
int k = 0;

if (++i || ++j && ++k)
{
    printf("true! \n");
}
pritnf("%d, %d, %d\n", i, j, k);
==>
true!
1, 0, 0

++i : 전위연산, i를 먼저 증가후 평가됨.
i++ : 후위연산, i로 먼저 평가한 수 1증가.

# short circuit : ||앞이 참이면 뒤 생략
||와 &&는 sequence point이므로, 우선순위가 생겨버림. 
따라서 i먼저, ||에 short circuit평가로 j, k 생략됨.
! 뒤를생략하기 쉽게 앞 조건을 세팅하면 실행속도 개선 가능

삼항연산자도 평가순서 보장함.
;도 평가순서보장함
함수를 실제 실행하기 전에 모든 매개변수도 평가됨
```

## 함수 범위(scope)

1. 블록 범위  
중괄호 {} 안에 선언한 것들은 그 블록 안에서만 사용 가능  
블록 안에 또 다른 블록을 넣을 수도 있다.  
안쪽 블록은 바깥 블록에 접근 가능하지만, 바깥 블록은 안쪽 블록에 접근 불가능.  
함수 중간에 블록열고 변수 선언 가능.  
* 코딩 표준: 변수가리기 (variable shadowing) 금지  
블록 안에 블록 바깥 변수랑 같은 이름의 변수를 만들지 말 것.

2. 파일 범위  
어떤 블록이나 매개변수 목록에도 안 속하고 파일안에 있는 것.  
global variable.  
코드 / 데이터 / 힙 / 스택  
메모리 중 데이터섹션에 들어감.  
함수는 코드 메모리섹션에 들어감  
전역변수는 컴파일하면 나오는 실행파일에 일부가 되며  
(보통 데이터 섹션에 들어감) 프로그램 실행시에   
그 데이터 섹션을 메모리로 로딩해서 메모리에 상주한다고 생각하세요.   
(반드시 그렇지는 않으니 개념상 그럼)  

``` C 
int g_x = 100; 
```  처럼 글로벌변수는 g_ prefix붙이기로 함.  

3. 함수 범위  
label레이블  
goto 같은데서 쓰는 것.
``` C
int main(int argc, char** argv)
{
    if (argc != 3) {
        goto exit;
    }
    printf("You have 3 arguments!");
exit:
    return 0;
}
```  

4. 함수 선언 범위  
함수 매개변수 범위. 매개변수끼리 참조하는게 된다네.
``` C
void do_something(
    double value,
    char array[10 * sizeof(value)]
);
```

## Keywords

### const
수정하면 안되는 변수를 수정하지 못하게!  
상수만 넣는거 아니고 변수도 C는 허용함.  
``` C
const int NUM_CARS = 30;
int calculate_rist(const int id)
{
    ...
    id *= 2;  /* 컴파일 오류 */
}
```
기본적으로 모든 변수에 const를 붙이자.  
정말 값 변경 필요한 변수에만 const를 생략하자.  


### goto 문
``` C
goto <label_name>;
...
<label_name>:
```  
반복문은 결국 goto를 사용하는 코드. 어셈블리어에는 반복문이란게 없음.  
goto가 유용한 경우
여러겹의 반복문에서 두단계 이상 점프하고플때

``` C
    do A
    if (error)
        goto out_a;
    do B
    if (error)
        goto out_b;
    do C
    if (error)
        goto out_c;
    goto out;
out_c:
    undo C
out_b:
    undo B
out_a:
    undo A
out:
    return ret;
/* out_c가 실행되면 out_b, out_a도 자동으로 실행이됨. 
stack 마냥 함수 실행이 필요할 때*/
```
goto best practice  
언제나 전방(아래쪽)으로만 점프할 것  
후방(위)로 점프하면 꼬임.  
nested 루프 빠져나올 때는 쓰면 좋음.  
한 함수안에 있는 여러개의 조건문이 공통된 코드를 실행해야할 때 써도됨.  
(ex: 함수 마지막에 성공/오류 조건 처리)
  
## 배열(array)
``` C
int nums[5];  /* 5 생략 가능 */
char name[10];  /* 10 생략 가능 */
float GPA[3] = {3.1f, 2.2f, -13.f};    /* 3 생략 가능 */
```
값형 (value type)  
참조형 (reference type)  
C는 값형으로도 배열을 만들 수 있다. 참조형으로도 만들 수 있다.  
어떻게 생성되는지 원리를 알려면 stack memory를 알아야 한다.  

### stack memory
![image](https://user-images.githubusercontent.com/15919242/211304660-675380b3-eab4-4de2-b7e0-92b00afc6d2f.png)

각 함수에서 사용하는 지역 변수 등을 임시적으로 저장하는 공간.  
스택 메모리크기는 프로그램 빌드 시에 결정됨.  
스택 메모리의 의치는 실행시에 결정됨.  
exe파일의 헤더에 이 정보들이 저장됨.  

기본자료형 변수는 스택 메모리를 차지함.  
모든 기본자료형 변수(char, int, float)를 new없이 사용할 수 있었던 이유가 바로 스택 메모리에 할당되서임.  
기본자료형을 함수 매개변수로 전달하면 스택에 복사본을 만듬 -> 값형(value type)  
new로 만든 데이터는 heap메모리에 할당되서 메모리 빌리고 반환하는 과정에서 구멍이 생길 수 있음 (사용하고 있는 주소 사이에 안쓰는 주소 생기는 것) 구멍을 찾아다니느라 속도가 좀 느려짐.  
![image](https://user-images.githubusercontent.com/15919242/211306387-3a16e15d-b7d0-447e-bb9d-9be7e4aa805e.png)
EBP: extended base pointer, 현재 스택 프레임의 기본(첫)주소  
ESP: extended stack pointer, 편재 스택 포인터 (스택 어디까지 차있는지)  
스택 프레임(stack frame) : 각 함수가 사용하는 스택 메모리의 범위 (EBP부터 ESP까지 범위)  

[어셈블리 진법 보충설명](http://carpedm20.blogspot.com/2012/08/this-page-is-going-to-be-about.html)  
cf) 0 = 0, 1 = 1, 2 = 2, ..., a = 10, b = 11, c = 12, d = 13, e = 14, f = 15  
16진법 표기 방법 1: 0x접두사 (0xf7 == 7 + 16*16)  
16진법 표기 방법 2: h접미사  (16h == 6 + 16)  
